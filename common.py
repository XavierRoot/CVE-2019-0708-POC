# common crypt
#https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/e78db616-689f-4b8a-8a99-525f7a433ee2
#https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-RDPBCGR/%5bMS-RDPBCGR%5d.pdf
# Write by Closethe
# Thanks Mateusz Garncarek ,360

import socket
import sys
import struct
import hashlib


def macData(macSaltKey, data):
    """
    @see: http://msdn.microsoft.com/en-us/library/cc241995.aspx
    @param macSaltKey: {str} mac key
    @param data: {str} data to sign
    @return: {str} signature
    """
    sha1Digest = hashlib.sha1()
    md5Digest = hashlib.md5()
    #encode length
    dataLength = len(data)
    dataLength = struct.pack('<I',dataLength)
    b36 = b"\x36" * 40
    sha1Digest.update(macSaltKey)
    sha1Digest.update(b36)
    sha1Digest.update(dataLength)
    sha1Digest.update(data)
    sha1Sig = sha1Digest.digest()
    b5c = b"\x5c" * 48
    md5Digest.update(macSaltKey)
    md5Digest.update(b5c)
    md5Digest.update(sha1Sig)
    return md5Digest.digest()

class RC4():

    def __init__(self,key):
        self.key = True
        # 初始化 加密变量
        self.j = 0
        self.y = 0
        self.S =list(range(256))
        # 计算初始化S序列
        j = 0 
        for i in list(range(256)):
            j = (j + self.S[i] + ord(key[i % len(key)])) % 256
            self.S[i], self.S[j] = self.S[j], self.S[i]

    def __call__(self,data):
        if data:
            if self.key:
                return self.enc(data)
            else:
                raise Exception("init first")
        else:
            return ""

    def enc(self,data):
        out = []
        for char in data:
            self.j = (self.j + 1) % 256
            self.y = (self.y + self.S[self.j]) % 256
            self.S[self.j], self.S[self.y] = self.S[self.y], self.S[self.j]
            out.append(chr(ord(char) ^ self.S[(self.S[self.j] + self.S[self.y]) % 256]))
        return ''.join(out)



def SaltedHash(Secret, I,client_random,server_random):
    md5 = hashlib.md5()
    sha1 = hashlib.sha1()
    Secretb = bytearray()
    Secretb.extend(map(ord, Secret))
    Ib = bytearray()
    Ib.extend(map(ord, I))
    client_randomb = bytearray()
    client_randomb.extend(map(ord, client_random))
    server_randomb = bytearray()
    server_randomb.extend(map(ord, server_random))
    sha1.update(Ib+Secretb+client_randomb+server_randomb)
    md5.update(Secretb+sha1.digest())
    return md5.digest()


def finalHash(key, client_random, server_random):
    """
    @summary: MD5(in0[:16] + in1[:32] + in2[:32])
    @param key: in 16
    @param random1: in 32
    @param random2: in 32
    @return MD5(in0[:16] + in1[:32] + in2[:32])
    """
    client_randomb = bytearray()
    client_randomb.extend(map(ord, client_random))
    server_randomb = bytearray()
    server_randomb.extend(map(ord, server_random))
    md5Digest = md5 = hashlib.md5()
    md5Digest.update(key)
    md5Digest.update(client_randomb)
    md5Digest.update(server_randomb)
    return md5Digest.digest()



